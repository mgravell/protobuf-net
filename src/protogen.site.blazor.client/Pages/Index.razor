@using System.Net.Http
@using Google.Protobuf.Reflection
@using System.IO
@using ProtoBuf.Reflection
@using ProtoBuf.Models
@using System.Text.Json

@inject HttpClient Http
@inject IJSRuntime JsRuntime;
@page "/"

<h2>Generator</h2>
<p><a href="/about">Wait... what is this?</a></p>
<p>If this tool has been useful: <a href="https://www.buymeacoffee.com/marcgravell" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png" alt="Buy Me A Coffee" style="height: auto !important;width: auto !important;" /></a></p>
<EditForm Model="@model" OnValidSubmit="@Generate">
    <DataAnnotationsValidator />
    <div class="row">
        <div class="form-group  col-6">
            <label for="language">Language</label>
            <InputSelect id="language" @bind-Value="model.Language" class="form-control" size="4">
                <option>(select)</option>
                @foreach (var language in Enum.GetValues(typeof(GeneratorViewModel.GeneratorLanguageEnum)))
                {
                    <option value="@language">@language</option>
                }
            </InputSelect>
        </div>
        @if (!model.SpecifyOptInProto && model.HasLanguageVersion())
        {
            <div class="form-group  col-6">
                <label for="language">@model.Language Version</label>
                <InputSelect id="language" @bind-Value="model.LanguageVersion" class="form-control mt-2" size="4">
                    <option>(select)</option>
                    @foreach (var version in model.GetLanguageVersions())
                        {
                        <option value="@version">@version</option>
                        }
                    /**/
                    /**/
                    /**/
                    /**/
                    /**/
                    /**/
                </InputSelect>
            </div>
        }
    </div>
    @if (model.IsProtobugGen())
    {
        <div class="form-check">
            <input class="form-check-input" type="checkbox" @onchange="ChangeOptionSpecification" id="opt_in_proto" />
            <label class="form-check-label" for="opt_in_proto">
                Specify options in .proto
            </label>
        </div>
        @if (!model.SpecifyOptInProto)
        {
            <div class="form-check">
                <input class="form-check-input" type="checkbox" @bind="model.OneOfEnum" id="oneof" />
                <label class="form-check-label" for="oneof">
                    <code>oneof</code> should use enum
                </label>
            </div>
        }
        <div class="form-check">
            <input class="form-check-input" type="checkbox" @bind="model.RepeatedEmitSetAccessors" id="repeated_accessors" />
            <label class="form-check-label" for="repeated_accessors">
                <code>repeated</code> should emit <code>set</code> accessors
            </label>
        </div>
        <div class="form-group">
            <label for="namingConvention">Naming convention</label>
            <InputSelect id="namingConvention" @bind-Value="model.NamingConvention" class="form-control col-4" size="4">
                @foreach (var namingConvention in Enum.GetValues(typeof(GeneratorViewModel.NamingConventionEnum)))
                    {
                    <option value="@namingConvention">@namingConvention</option>
                    }
                /**/
                /**/
            </InputSelect>
        </div>
    }
    <div class="form-group">
        <label for="protoContent">.proto file content</label> <button type="button" class="btn btn-sm btn-secondary" @onclick="LoadSample">Load descriptor.proto</button>
        <textarea class="form-control" @bind="model.ProtoContent" id="protoContent" rows="3" @ref:suppressField @ref="protoEditor">

        </textarea>
    </div>
    <button type="submit" class="btn btn-primary">Generate</button>

    <ValidationSummary />
</EditForm>
@if (errors != null)
{
    <div class="mt-5">
        @foreach (var error in errors)
        {
            <div class="alert @(error.IsWarning ? "alert-warning":"alert-danger")">
                @error.ToString()
            </div>
        }
    </div>
}
@if(exceptionMessage != null)
{
    <pre class="alert alert-danger">@exceptionMessage</pre>
}
@if (codeFiles != null)
{
    @foreach (var file in codeFiles)
    {
        <h2 class="mt-5">Generated Code</h2>
        <div class="form-group">
            <textarea rows="100" class="form-control">@file.Text</textarea>
        </div>
    }
}
@code{
    ElementReference protoEditor;

    Error[] errors;

    private GeneratorViewModel model = new GeneratorViewModel();

    private List<CodeFile> codeFiles;

    private string exceptionMessage;

    protected async Task LoadSample()
    {
        model.ProtoContent = await Http.GetStringAsync("https://raw.githubusercontent.com/google/protobuf/master/src/google/protobuf/descriptor.proto");
    }
    //we use this for inserting options at the end of the script without erasing user custom content
    private const string ProtoOptionCommentDelimiter = "//endof options";
    protected async Task ChangeOptionSpecification(UIChangeEventArgs e)
    {
        model.SpecifyOptInProto = (bool)e.Value;
        if (model.ProtoContent != null)
        {

            model.ProtoContent = model.ProtoContent.Substring(model.ProtoContent.IndexOf(ProtoOptionCommentDelimiter) + ProtoOptionCommentDelimiter.Length);
        }

        if (model.SpecifyOptInProto)
        {
            //we could have this content hard coded but it was like this before
            var optContent = await Http.GetStringAsync("https://gist.githubusercontent.com/mgravell/c545f903467fd7fa441ad80c5433d331/raw/59e0681069463c016eb06a630991945aa783b90f/configure_protogen.proto");
            model.ProtoContent = $"{optContent}{Environment.NewLine}{ProtoOptionCommentDelimiter}{Environment.NewLine}{model.ProtoContent}";
        }
    }

    protected async Task Generate()
    {
        codeFiles = null;
        exceptionMessage = null;
        errors = null;
        using (var reader = new StringReader(model.ProtoContent))
        {
            var set = new FileDescriptorSet
            {
                ImportValidator = path => true,
            };
            set.Add("my.proto", true, reader);

            set.Process();
            errors = set.GetErrors();
            if (errors.Any())
            {
                return;
            }

            if (model.IsProtobugGen())
            {
                ProtobufnetGenerate(set);
            }
            else
            {
                await ProtocGenerate();
            }
        }
    }
    private async Task ProtocGenerate()
    {
        var response = await Http.PostAsync("http://localhost:53831/generate", new FormUrlEncodedContent(
            new Dictionary<string, string>() {
                {"schema", model.ProtoContent },
                {"tooling", model.GetProtocTooling() }
            }
          ));
        var content = await response.Content.ReadAsStringAsync();
        if (response.IsSuccessStatusCode)
        {
            codeFiles = JsonSerializer.Deserialize<List<CodeFile>>(content);
        }
        else
        {
            if (content.Contains("Exception"))//did not find a better way for handling exception or error file
            {
                this.exceptionMessage = content;
            }
            else
            {
                this.errors= JsonSerializer.Deserialize<Error[]>(content);
            }
        }
    }
    private void ProtobufnetGenerate(FileDescriptorSet set)
    {
        CodeGenerator codegen = model.GetCodeGenerator();
        codeFiles = codegen.Generate(set, model.GetNameNormalizerForConvention(), model.GetOptions()).ToList();
    }

}
