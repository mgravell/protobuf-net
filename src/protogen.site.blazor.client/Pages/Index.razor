@using System.Net.Http
@using Google.Protobuf.Reflection
@using System.IO
@using ProtoBuf.Reflection
@using ProtoBuf.Models
@using System.Text.Json

@inject HttpClient Http
@inject IJSRuntime JsRuntime;
@page "/"

<EditForm Model="@model" OnValidSubmit="@Generate">
    <DataAnnotationsValidator />
    <div class="row  pt-2">
        <div class="col-5">

            <h2>Code Generator</h2>

            <div class="form-group" style="height:calc(100% - 230px)">
                <textarea style="height: calc(100% - 30px)" placeholder=".proto file content" class="form-control" @bind="model.ProtoContent" id="protoContent" @ref="protoEditor"></textarea>
                <button type="button" class="btn btn-sm btn-secondary" @onclick="LoadSample">Load descriptor.proto</button>
            </div>



        </div>
        <div class="col-2">
            <button type="submit" class="btn btn-primary btn-block" disabled="@loading">
                @if (loading)
                {
                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    <text> Generating </text>
                }
                else
                {
                    <text> Generate </text>
                }
            </button>

            <ValidationSummary />
            <div class="form-group mb-1 ">
                <label for="language">Language</label>
                <InputSelect id="language" @bind-Value="model.Language" class="form-control">

                    @foreach (var language in Enum.GetValues(typeof(GeneratorViewModel.GeneratorLanguageEnum)))
                    {
                        <option value="@language">@language</option>
                    }
                </InputSelect>
            </div>

            @if (model.IsProtobugGen())
            {
                <div class="form-group mb-1  form-check">
                    <input class="form-check-input" type="checkbox" @onchange="ChangeOptionSpecification" id="opt_in_proto" />
                    <label class="form-check-label" for="opt_in_proto">
                        Specify options in .proto
                    </label>
                </div>

                @if (!model.SpecifyOptInProto)
                {
                    @if (model.HasLanguageVersion())
                    {
                        <div class="form-group mb-1  ml-2">
                            <label for="version">@model.Language Version</label>
                            <InputSelect id="version" @bind-Value="model.LanguageVersion" class="form-control">

                                @foreach (var version in model.GetLanguageVersions())
                                            {
                                    <option value="@version">@version</option>
                                            }
                                /**/
                                /**/
                                /**/
                                /**/
                                /**/
                                /**/
                                /**/
                                /**/
                                /**/
                            </InputSelect>
                        </div>
                    }
                    <div class="form-group form-check ml-2 mb-1 ">
                        <input class="form-check-input" type="checkbox" @bind="model.OneOfEnum" id="oneof" />
                        <label class="form-check-label" for="oneof">
                            <code>oneof</code> should use enum
                        </label>
                    </div>
                }
                <div class="form-group form-check mb-1 ">
                    <input class="form-check-input" type="checkbox" @bind="model.RepeatedEmitSetAccessors" id="repeated_accessors" />
                    <label class="form-check-label" for="repeated_accessors">
                        <code>repeated</code> should emit <code>set</code> accessors
                    </label>
                </div>
                <div class="form-group mb-1 ">
                    <label for="namingConvention">Naming convention</label>
                    <InputSelect id="namingConvention" @bind-Value="model.NamingConvention" class="form-control">
                        @foreach (var namingConvention in Enum.GetValues(typeof(GeneratorViewModel.NamingConventionEnum)))
                            {
                            <option value="@namingConvention">@namingConvention</option>
                            }
                    </InputSelect>
                </div>
            }
        </div>
        <div class="col-5">
            @if (errors != null)
            {

                @foreach (var error in errors)
                {
                    <div class="alert @(error.IsWarning ? "alert-warning":"alert-danger")">
                        @error.ToString()
                    </div>
                }
            }
            @if (exceptionMessage != null)
            {
                <pre class="alert alert-danger">@exceptionMessage</pre>
            }
            @if (codeFiles != null)
            {
                <h2>Generated Code</h2>
                @foreach (var file in codeFiles)
                {
                    <div class="form-group" style="height:calc(100% - 230px)">
                        <textarea style="height: 100%" class="form-control">@file.Text</textarea>
                    </div>
                }
            }
        </div>
    </div>

</EditForm>
@code{
    bool loading = false;

    ElementReference protoEditor;

    Error[] errors;

    private GeneratorViewModel model = new GeneratorViewModel();

    private List<CodeFile> codeFiles;

    private string exceptionMessage;

    protected async Task LoadSample()
    {
        model.ProtoContent = await Http.GetStringAsync("https://raw.githubusercontent.com/google/protobuf/master/src/google/protobuf/descriptor.proto");
    }
    //we use this for inserting options at the end of the script without erasing user custom content
    private const string ProtoOptionCommentDelimiter = "//endof options";
    protected async Task ChangeOptionSpecification(ChangeEventArgs e)
    {
        model.SpecifyOptInProto = (bool)e.Value;
        if (model.ProtoContent != null)
        {

            model.ProtoContent = model.ProtoContent.Substring(model.ProtoContent.IndexOf(ProtoOptionCommentDelimiter) + ProtoOptionCommentDelimiter.Length);
        }

        if (model.SpecifyOptInProto)
        {
            //we could have this content hard coded but it was like this before
            var optContent = await Http.GetStringAsync("https://gist.githubusercontent.com/mgravell/c545f903467fd7fa441ad80c5433d331/raw/59e0681069463c016eb06a630991945aa783b90f/configure_protogen.proto");
            model.ProtoContent = $"{optContent}{Environment.NewLine}{ProtoOptionCommentDelimiter}{Environment.NewLine}{model.ProtoContent}";
        }
    }

    protected async Task Generate()
    {
        try
        {
            loading = true;
            codeFiles = null;
            exceptionMessage = null;
            errors = null;
            using (var reader = new StringReader(model.ProtoContent))
            {
                var set = new FileDescriptorSet
                {
                    ImportValidator = path => true,
                };
                set.Add("my.proto", true, reader);

                set.Process();
                errors = set.GetErrors();
                if (errors.Any())
                {
                    return;
                }

                if (model.IsProtobugGen())
                {
                    ProtobufnetGenerate(set);
                }
                else
                {
                    await ProtocGenerate();
                }
            }
        }
        catch (Exception e)
        {
            exceptionMessage = "An unhandled exception occured : " + e.Message;
        }
        finally
        {
            loading = false;
        }
    }
    private async Task ProtocGenerate()
    {
        var response = await Http.PostAsync("/generate", new FormUrlEncodedContent(
            new Dictionary<string, string>() {
                {"schema", model.ProtoContent },
                {"tooling", model.GetProtocTooling() }
                                                    }
          ));
        var content = await response.Content.ReadAsStringAsync();
        if (response.IsSuccessStatusCode)
        {
            using (var output = JsonDocument.Parse(content))
            {
                codeFiles = output.RootElement.EnumerateArray()
                    .Select(j => new CodeFile(
                        j.GetProperty("name").GetString(),
                        j.GetProperty("text").GetString()))
                    .ToList();
            }
        }
        else
        {
            if (content.Contains("Exception"))//did not find a better way for handling exception or error file
            {
                this.exceptionMessage = content;
            }
            else
            {
                using (var output = JsonDocument.Parse(content))
                    errors = Error.Parse(
                        output.RootElement.GetProperty("stdout").GetRawText(),
                        output.RootElement.GetProperty("stderr").GetRawText()
                    );
            }
        }
    }
    private void ProtobufnetGenerate(FileDescriptorSet set)
    {
        CodeGenerator codegen = model.GetCodeGenerator();
        codeFiles = codegen.Generate(set, model.GetNameNormalizerForConvention(), model.GetOptions()).ToList();
    }

}
