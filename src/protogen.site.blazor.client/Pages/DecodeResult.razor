@using ProtoBuf.Models

@try
{
    ProtoBuf.SubItemToken tok = default(ProtoBuf.SubItemToken);
    using (var reader = DecodeModel.GetReader(out var state))
    {
        int field;
        long start = 0;
        while ((field = reader.ReadFieldHeader(ref state)) > 0)
        {
            @if (start == 0 && field == DecodeModel.SkipField && reader.WireType == ProtoBuf.WireType.StartGroup)
            {
                tok = ProtoBuf.ProtoReader.StartSubItem(reader, ref state);
                start = reader.GetPosition(ref state);
                continue;
            }
            @if (start != 0)
            {
                <hr />
            }
            long headerEnd = reader.GetPosition(ref state);

            <p data-offset="@start">
                @DecodeModel.AsHex(start, headerEnd - start) = field
                <b>@(field)</b>
                <span class="badge badge-info" title="Data Type">
                    @(reader.WireType == ProtoBuf.WireType.Variant ? "Varint" : reader.WireType.ToString())
                </span>
            </p>
            switch (reader.WireType)
            {
                case ProtoBuf.WireType.Variant:
                    var val = reader.ReadInt64(ref state);
                    <p>
                        Hexa = <b>@DecodeModel.AsHex(headerEnd, reader.GetPosition(ref state) - headerEnd)</b>.
                        Raw = <b>@(val)</b>.
                        ZigZag = <b>@(Zag(val))</b>.
                    </p>
                    break;
                case ProtoBuf.WireType.StartGroup:
                    reader.SkipField(ref state);
                    <p>Payload (inc. terminator) = @DecodeModel.AsHex(headerEnd, reader.GetPosition(ref state) - headerEnd)</p>

                    <div style="padding-left: 2em">
                        @if (DecodeModel.Deep)
                        {
                            <DecodeResult DecodeModel="DecodeModel.Slice(start, reader.GetPosition(ref state) - start, field)"></DecodeResult>

                        }
                        else
                        {
                            <DecodeResultDeeper Hex="@(DecodeModel.AsHex(headerEnd, reader.GetPosition(ref state) - headerEnd))"></DecodeResultDeeper>
                        }
                    </div>
                    break;
                case ProtoBuf.WireType.String:
                    {
                        var payloadBytes = ProtoBuf.ProtoReader.AppendBytes(null, reader, ref state);
                        var lenLen = reader.GetPosition(ref state) - payloadBytes.Length - headerEnd;
                        <p>
                            Length = <b>@(payloadBytes.Length)</b>(@DecodeModel.AsHex(headerEnd, lenLen))
                        </p>
                        var slice = new DecodeModel(payloadBytes, DecodeModel.Deep);
                        if (slice.Count == 0)
                        {
                            <p>(Empty payload)</p>
                        }
                        else if (slice.Count > 256)
                        {
                            <p>(@slice.Count bytes)</p>
                        }
                        else
                        {
                            <p>Payload = @slice.AsHex()</p>
                            var s = slice.AsString();
                            if (!string.IsNullOrEmpty(s))
                            {
                                <p>UTF8 = @s</p>
                            }
                        }
                        if (slice.Count == 0)
                        { }
                        else if (slice.CouldBeProto())
                        {
                            <div style="padding-left: 2em">
                                @if (DecodeModel.Deep)
                                {
                                    <DecodeResult DecodeModel="slice"></DecodeResult>
                                }
                                else
                                {
                                    <DecodeResultDeeper Hex="@slice.AsHex()"></DecodeResultDeeper>
                                }
                            </div>
                        }
                    }
                    break;
                case ProtoBuf.WireType.Fixed64:
                    var val64 = reader.ReadInt64(ref state);
                    <p>
                        Hex = <b>@DecodeModel.AsHex(headerEnd, reader.GetPosition(ref state) - headerEnd)</b>.
                        Integer = <b>@(val64)</b>.
                        Floating point = <b>@(ToDouble(val64))</b>.
                    </p>
                    break;
                case ProtoBuf.WireType.Fixed32:
                    var val32 = reader.ReadInt32(ref state);
                    <p>
                        Hex = @DecodeModel.AsHex(headerEnd, reader.GetPosition(ref state) - headerEnd) .
                        Integer = <b>@(val32)</b>.
                        Floating point = <b>@(ToSingle(val32))</b>.
                    </p>
                    break;
                case ProtoBuf.WireType.EndGroup:
                    break;
                default:
                    <p>Unexpected wire-type: @(reader.WireType)</p>
                    break;
            }
            start = reader.GetPosition(ref state);
        }
        @if (DecodeModel.SkipField > 0 && start != 0)
        {
            ProtoBuf.ProtoReader.EndSubItem(tok, reader, ref state);
            var suffixLen = reader.GetPosition(ref state) - start;
            if (suffixLen != 0)
            {
                <hr />
                <p>
                    @DecodeModel.AsHex(start, suffixLen) = Field <b>@(DecodeModel.SkipField)</b>,
                    <span class="badge">@(ProtoBuf.WireType.EndGroup)</span>
                </p>
            }
        }
        @if (reader.GetPosition(ref state) < DecodeModel.Count)
        {
            <p>Remaining data: @DecodeModel.AsHex(reader.GetPosition(ref state), DecodeModel.Count - reader.GetPosition(ref state))</p>
            <DecodeResultDeeper Hex="DecodeModel.AsHex(reader.Position, DecodeModel.Count - reader.Position)"></DecodeResultDeeper>
        }
    }
}
catch (Exception ex)
{
    <div class="alert alert-danger">
        <p>error: @(ex.Message)</p>
        <pre> @(ex.StackTrace)</pre>
    </div>
}


@code {
    [Parameter]
    public DecodeModel DecodeModel { get; set; }

    double ToDouble(long val) => BitConverter.ToDouble(BitConverter.GetBytes(val), 0);

    double ToSingle(int val) => BitConverter.ToSingle(BitConverter.GetBytes(val), 0);

    long Zag(long value)
    {
        const long Int64Msb = ((long)1) << 63;
        return (-(value & 0x01L)) ^ ((value >> 1) & ~Int64Msb);
    }

}
