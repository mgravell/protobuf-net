@using ProtoBuf.Models
@using System.Text
@using System.IO
@WriteTier((DecodeModel.GetReader(),0))

@code {

    [Parameter]
    public DecodeModel DecodeModel { get; set; }

    private RenderFragment<(int depth, string msg)> WriteLine = t => @<p>@t.depth - @t.msg</p>;

    private RenderFragment<(ProtoReader reader, int depth)> WriteTier;

    protected override void OnInitialized()
    {
        WriteTier = t => @<div>
        @{
            long start = t.reader.Position;
            int field;
            while ((field = t.reader.ReadFieldHeader()) > 0)
            {
                long payloadStart = t.reader.Position;
           
                @WriteLine((t.depth, $"field {t.reader.FieldNumber}: {AsHex(start, payloadStart - start)}, {t.reader.WireType}"))
                switch (t.reader.WireType)
                {
                    case WireType.Varint:
                    case WireType.Fixed32:
                    case WireType.Fixed64:
                        // just pretending everything is integers for now, for simplicity
                        var val = t.reader.ReadInt64();
                        @WriteLine((t.depth, $"val {val}, {AsHex(payloadStart, t.reader.Position - payloadStart)}"))
                        break;
                    case WireType.String:
                        // now, this could be a sub-message, or it could be a UTF8 string
                        // this isn't efficient, but it works
                        var payloadBytes = ProtoReader.AppendBytes(null, t.reader);
                        @WriteLine((t.depth, $"length {payloadBytes.Length}, {AsHex(payloadStart, t.reader.Position - payloadStart - payloadBytes.Length)}")                   )
                        try
                        {
                            var utf8 = Encoding.UTF8.GetString(payloadBytes);
                            if (utf8.Length > 16)
                                utf8 = utf8.Substring(0, 16) + "...(total " + utf8.Length + " chars)";
                            @WriteLine((t.depth, $"as utf8: {utf8}"))   
                        }
                        catch { }

                        using (var subReader = TestCouldBeProto(payloadBytes))
                        {
                            if (subReader != null)
                            {
                                @WriteLine((t.depth, " as sub-object:"))   
                                @WriteTier((subReader, t.depth+1))
                            }
                        }
                        break;
                    case WireType.StartGroup:
                        // explicit group
                        var tok = ProtoReader.StartSubItem(t.reader);
                        @WriteLine((t.depth, $"group, {AsHex(payloadStart, t.reader.Position - payloadStart)}"))    
                        @WriteTier((t.reader, t.depth+1))
                        ProtoReader.EndSubItem(tok, t.reader);
                        break;
                    default:
                        throw new InvalidOperationException("oops we missed this!");
                }
                start = t.reader.Position;
            }
        }
        </div>;
    }


    string AsHex(long start, long count) => BitConverter.ToString(DecodeModel.Data, checked((int)start), checked((int)count));

    static ProtoReader TestCouldBeProto(byte[] payload)
    {
        if (payload == null || payload.Length == 0)
            return null; // not worth bothering with
        try
        {
            var ms = new MemoryStream(payload);
        #pragma warning disable CS0618
            using (var test = ProtoReader.Create(ms, null, null))
        #pragma warning restore CS0618
            {   // can we make it to the end without failing?
                int field;
                while ((field = test.ReadFieldHeader()) > 0)
                    test.SkipField();
            }
            // if we got this far... it has potential!

            ms.Position = 0; //rewind and do it all again!
        #pragma warning disable CS0618
            return ProtoReader.Create(ms, null, null);
        #pragma warning restore CS0618
        }
        catch
        {
            // nope, then
            return null;
        }
    }
}
