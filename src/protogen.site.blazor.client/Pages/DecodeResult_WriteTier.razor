
@using System.Text
@using System.IO
@{

    long start = Reader.Position;
    int field;
    while ((field = Reader.ReadFieldHeader()) > 0)
    {
        long payloadStart = Reader.Position;

        <DecodeResult_WriteLine Depth="Depth" Msg="@( $"field {Reader.FieldNumber}: {AsHex(start, payloadStart - start)}, {Reader.WireType}")"></DecodeResult_WriteLine>

        switch (Reader.WireType)
        {
            case WireType.Varint:
            case WireType.Fixed32:
            case WireType.Fixed64:
                // just pretending everything is integers for now, for simplicity
                var val = Reader.ReadInt64();
                <DecodeResult_WriteLine Depth="Depth" Msg="@($"val {val}, {AsHex(payloadStart, Reader.Position - payloadStart)}")"></DecodeResult_WriteLine>
                break;
            case WireType.String:
                // now, this could be a sub-message, or it could be a UTF8 string
                // this isn't efficient, but it works
                var payloadBytes = ProtoReader.AppendBytes(null, Reader);
                <DecodeResult_WriteLine Depth="Depth" Msg="@($"length {payloadBytes.Length}, {AsHex(payloadStart, Reader.Position - payloadStart - payloadBytes.Length)}")"></DecodeResult_WriteLine>
                try
                {
                    var utf8 = Encoding.UTF8.GetString(payloadBytes);
                    if (utf8.Length > 16)
                        utf8 = utf8.Substring(0, 16) + "...(total " + utf8.Length + " chars)";
                    <DecodeResult_WriteLine Depth="Depth" Msg="@($"as utf8: {utf8}")"></DecodeResult_WriteLine>

                }
                catch { }

                using (var subReader = TestCouldBeProto(payloadBytes))
                {
                    if (subReader != null)
                    {
                        <DecodeResult_WriteLine Depth="Depth" Msg="@(" as sub-object:")"></DecodeResult_WriteLine>
                        <DecodeResult_WriteTier Reader="subReader" Depth="@(Depth +1)"></DecodeResult_WriteTier>
                    }
                }
                break;
            case WireType.StartGroup:
                // explicit group
                var tok = ProtoReader.StartSubItem(Reader);
                <DecodeResult_WriteLine Depth="Depth" Msg="@( $"group, {AsHex(payloadStart, Reader.Position - payloadStart)}")"></DecodeResult_WriteLine>
                <DecodeResult_WriteTier Reader="Reader" Depth="@(Depth +1)" Bytes="Bytes">

                </DecodeResult_WriteTier>
                ProtoReader.EndSubItem(tok, Reader);
                break;
            default:
                throw new InvalidOperationException("oops we missed this!");
        }
        start = Reader.Position;
    }
}
@code {
    [Parameter] public ProtoReader Reader { get; set; }
    [Parameter] public int Depth { get; set; }
    [Parameter] public byte[] Bytes { get; set; }

    private RenderFragment<(ProtoReader reader, int depth, byte[] data)> WriteTier;

    protected override void OnInitialized()
    {
        WriteTier = t =>@<div>
        @{

            long start = t.reader.Position;
            int field;
            while ((field = t.reader.ReadFieldHeader()) > 0)
            {
                long payloadStart = t.reader.Position;
            }
            @WriteTier((t.reader, t.depth, t.data))
        }
    </div>;
}


string AsHex(long start, long count) => BitConverter.ToString(Bytes, checked((int)start), checked((int)count));

static ProtoReader TestCouldBeProto(byte[] payload)
{
  if (payload == null || payload.Length == 0)
      return null; // not worth bothering with
  try
  {
      var ms = new MemoryStream(payload);
#pragma warning disable CS0618
      using (var test = ProtoReader.Create(ms, null, null))
#pragma warning restore CS0618
      {   // can we make it to the end without failing?
          int field;
          while ((field = test.ReadFieldHeader()) > 0)
              test.SkipField();
      }
      // if we got this far... it has potential!

      ms.Position = 0; //rewind and do it all again!
#pragma warning disable CS0618
      return ProtoReader.Create(ms, null, null);
#pragma warning restore CS0618
  }
  catch
  {
      // nope, then
      return null;
  }
}
}
